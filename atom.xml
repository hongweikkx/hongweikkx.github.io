<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kkx&#39;s blogs</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hongweikkx.github.io/"/>
  <updated>2020-07-01T06:07:55.409Z</updated>
  <id>https://hongweikkx.github.io/</id>
  
  <author>
    <name>kkx</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ssh远程登录辅助管理工具</title>
    <link href="https://hongweikkx.github.io/2020/07/01/ssh%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E8%BE%85%E5%8A%A9%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <id>https://hongweikkx.github.io/2020/07/01/ssh远程登录辅助管理工具/</id>
    <published>2020-07-01T06:06:28.000Z</published>
    <updated>2020-07-01T06:07:55.409Z</updated>
    
    <content type="html"><![CDATA[<p>在ssh 登录时我们经常会遇到</p><ul><li>每次登录都需要输入密码， 很麻烦</li><li>需要登录多个 user@host ，难以记忆<a id="more"></a></li></ul><h2 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h2><p>基于上述问题， 我基于sshpass 开发了一个shell脚本，repo 地址：<a href="https://github.com/hongweikkx/sshp" target="_blank" rel="noopener">https://github.com/hongweikkx/sshp</a></p><ol><li>将密码记录在文本中， 使用sshpass 就不需要每次输入密码</li><li>用短名字来替换user@host， 方便使用、便于记忆。 使用时只需要 <code>sshp shortname</code></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在ssh 登录时我们经常会遇到&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每次登录都需要输入密码， 很麻烦&lt;/li&gt;
&lt;li&gt;需要登录多个 user@host ，难以记忆
    
    </summary>
    
    
      <category term="golang" scheme="https://hongweikkx.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>(感)禅与摩托车维修艺术</title>
    <link href="https://hongweikkx.github.io/2019/01/26/%E6%84%9F-%E7%A6%85%E4%B8%8E%E6%91%A9%E6%89%98%E8%BD%A6%E7%BB%B4%E4%BF%AE%E8%89%BA%E6%9C%AF/"/>
    <id>https://hongweikkx.github.io/2019/01/26/感-禅与摩托车维修艺术/</id>
    <published>2019-01-26T10:36:28.000Z</published>
    <updated>2019-01-26T10:40:49.030Z</updated>
    
    <content type="html"><![CDATA[<p>哪怕霍金称这本书可以让人们不必处于伟大的智慧和哲学之外，它仍然是一本难以读下去的书，<br>尤其是当你看完书，去总结“良质” 的时候，那些散落的观点，似乎都在说，“良质是拒绝被定义的”。 有人用心电交流，进取心，喜欢，内心平静，活在此处来定义”良质“， 很显然都是有失偏颇的。良质包括了他们所有，而他们却并非等同于良质。<br> <a id="more"></a><br>秉承作者在文中所说”我认为如果能够改善人们每天的生活，那么哲学就是好的，否则宁可忘记它”,so，，，暂时忘掉对于良质的定义，可以看下作者提出的良质对于我们生活有什么影响。</p><p>比如写作，作者让学生去写一篇关于波斯曼（城市）的文章，可是学生没有办法下笔， 因为她想不出波斯曼有什么值得重复写下来的地方。</p><p>又比如摩托车，现代工业的产物，人们喜欢使用它，也喜欢用各种东西来装饰它，并希望它可以一直运行良好的运行下去。但问题总会出现，而且我们没有办法从表面上看出摩托车的问题到底出在哪里，所以只能气愤的把车交给维修的技术人员。而技术人员也只会用通用的方法去解决这个问题，根本不关心眼前的这辆摩托车的个性问题。</p><p>作者把这些都归结于理性科学和浪漫表象之间的对立隔离。而良质的提出就是要找到解决的方法，扩展理性的范围，涵盖非理性的层面。</p><p>比如写作，当作者将问题的范围从波斯曼缩小到一块砖的时候， 学生终于有的写了， 因为她必须直接的，不受任何阻碍的观察这块砖（浪漫），而且之前也没有人写这块砖， 她不需要去模仿任何人。作者认为从写作的角度出发， 模仿是一种罪恶，因为有太多的规则需要被遵守， 而真正的作家在写作的时候是没有那些原则的， 他们只是把他们认为对的东西写下来， 然后再回头看看是否有问题， 如果修辞不对，可以再修正。红楼梦里面曹公借林黛玉之口讲做诗的时候， 说出的“词不毁意” 也正是这个意思。</p><p>又比如修理摩托车，作者认为你需要关心摩托车，不应该一出现问题就交给技术人员。即使你不知所措，被问题卡住，也可以摸索的前进。作者认为传统理性，最大的遗憾就是不曾教导人们在卡住的时候如何自己摸索着解决问题。</p><p>所有上面的解决都是良质，so，，，良质到底是什么？<br>其实良质是一个事件，而不是一个品质。我认为良质是用心的观察和感受，并心平气和的关注于你当下的工作，将工作完成到你认为对的，或者你喜欢的层面，并根据工作的反应，调整你认为对或者喜欢的方向，持续的优化。</p><p>整本书虽然作者在提出良质，解释良质。 但书中观点总是应接不暇， 比如科学的无限假设，休谟科学的经验主义 vs 康德的直觉和感官认知 的思辨，柏拉图和亚里士多德等。 当然书中还提出了在追逐良质的过程中，可能出现的陷阱， 并一一给出了解决的方法。</p><p>这本书和良质一样很难归结为哪一类，有思辨，哲学 也有实用的方法，还有作者和儿子的旅游和感情。或者可以说整本书就是高级良质的努力吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;哪怕霍金称这本书可以让人们不必处于伟大的智慧和哲学之外，它仍然是一本难以读下去的书，&lt;br&gt;尤其是当你看完书，去总结“良质” 的时候，那些散落的观点，似乎都在说，“良质是拒绝被定义的”。 有人用心电交流，进取心，喜欢，内心平静，活在此处来定义”良质“， 很显然都是有失偏颇的。良质包括了他们所有，而他们却并非等同于良质。&lt;br&gt;
    
    </summary>
    
    
      <category term="读书" scheme="https://hongweikkx.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>protobuff 在实际游戏开发中的协议封装</title>
    <link href="https://hongweikkx.github.io/2019/01/11/protobuff-%E5%9C%A8%E5%AE%9E%E9%99%85%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%8D%8F%E8%AE%AE%E5%B0%81%E8%A3%85/"/>
    <id>https://hongweikkx.github.io/2019/01/11/protobuff-在实际游戏开发中的协议封装/</id>
    <published>2019-01-11T04:28:30.000Z</published>
    <updated>2019-01-11T05:53:20.666Z</updated>
    
    <content type="html"><![CDATA[<p>protobuff 本身并没有做切分数据流。</p><h3 id="1-切包方式"><a href="#1-切包方式" class="headerlink" title="1. 切包方式"></a>1. 切包方式</h3><p>所以在使用的时候，需要程序自己做切分数据流的操作。实际项目中（我见过的主要是游戏项目）大概有这么几种切分的方式<br><a id="more"></a></p><h5 id="1-gt-len-id-data-方式"><a href="#1-gt-len-id-data-方式" class="headerlink" title="1&gt;. len + id + data  方式"></a>1&gt;. len + id + data  方式</h5><p>len:长度, id:协议号, data:proto 数据。 len可以为定长，也仿造pb(protobuff)中的<a href="https://kakashi.me/2019/01/03/protobuff-vs-json/" target="_blank" rel="noopener">varint类型</a>来做。<br><br>切分方式就是通过len来知道包有多大，然后通过id映射到pb自己的包解析中去。</p><h4 id="2-gt-len-循环的unique-id-16-section-8-method-8-data"><a href="#2-gt-len-循环的unique-id-16-section-8-method-8-data" class="headerlink" title="2&gt;. len + 循环的unique id(16) + section(8) + method(8) + data"></a>2&gt;. len + 循环的unique id(16) + section(8) + method(8) + data</h4><p>unique_id和事先约定好的key做了协议加密<br>section + method 组成了协议号<br>切分方式类似于第一种，只是多加了协议加密  </p><h4 id="3-gt-len-nameLen-message-name-data-check-sum-冗余校验"><a href="#3-gt-len-nameLen-message-name-data-check-sum-冗余校验" class="headerlink" title="3&gt;. len + nameLen + message_name + data + check_sum (冗余校验)"></a>3&gt;. len + nameLen + message_name + data + check_sum (冗余校验)</h4><p>切分方式是通过len来切包，通过message_name 来找到对应的方式来解码，而不是通过id。<br>增加了check_sum来做校验。 buy why check_sum? tcp的可靠性有多高？ why crc-32? </p><p>总结下，<br><br><b> <font color="#A52A2A" size="4"> 切分方式 = len + id(or message_name) + data + encryption(可选) + check_sum(可选)</font> </b></p><h3 id="2-为什么pb自己不做切包？"><a href="#2-为什么pb自己不做切包？" class="headerlink" title="2. 为什么pb自己不做切包？"></a>2. 为什么pb自己不做切包？</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;protobuff 本身并没有做切分数据流。&lt;/p&gt;
&lt;h3 id=&quot;1-切包方式&quot;&gt;&lt;a href=&quot;#1-切包方式&quot; class=&quot;headerlink&quot; title=&quot;1. 切包方式&quot;&gt;&lt;/a&gt;1. 切包方式&lt;/h3&gt;&lt;p&gt;所以在使用的时候，需要程序自己做切分数据流的操作。实际项目中（我见过的主要是游戏项目）大概有这么几种切分的方式&lt;br&gt;
    
    </summary>
    
    
      <category term="protobuff" scheme="https://hongweikkx.github.io/tags/protobuff/"/>
    
      <category term="游戏开发" scheme="https://hongweikkx.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>protobuff vs json?</title>
    <link href="https://hongweikkx.github.io/2019/01/03/protobuff-vs-json/"/>
    <id>https://hongweikkx.github.io/2019/01/03/protobuff-vs-json/</id>
    <published>2019-01-03T08:45:36.000Z</published>
    <updated>2019-01-03T11:12:48.831Z</updated>
    
    <content type="html"><![CDATA[<p>本文讨论 protobuff 和 json 作为消息传递格式的优缺点。<br><br>消息处理的过程包括：接收到二进制 -&gt; 切包 -&gt; 解码 -&gt; 消息分发 -&gt; 处理消息 <br><br>所以我们决定从 1. 包的大小 2. 编解码速度 来讨论两者<br><a id="more"></a></p><h3 id="1-包的大小"><a href="#1-包的大小" class="headerlink" title="1. 包的大小"></a>1. 包的大小</h3><h4 id="protobuff-的编码方式"><a href="#protobuff-的编码方式" class="headerlink" title="protobuff 的编码方式"></a>protobuff 的编码方式</h4><p>在看protobuff 之前，我们需要知道pb并没有自己切tcp包的代码，常用的做法还是程序自己去做切包处理。切好包之后，自然会有几个问题？<br></p><ol><li>pb 是用 长度+type+data 来确定字段和字段的边界的么？<br></li><li>如果是 那么长度字段是定长的么？ 如果定长，那么长度字段是否太过浪费。。 <br></li><li>如果不是 长度+type+data, 那么怎么解决string的传输呢？毕竟int型可以定长，string肯定不是定长的。 <br></li></ol><p>pb用很聪明的方法解决了以上的问题：<br><br>pb在内部有六种基本数据类型。分别是 <br><br>-define(TYPE_VARINT, 0).<br><br>-define(TYPE_64BIT, 1).<br><br>-define(TYPE_STRING, 2).<br><br>-define(TYPE_START_GROUP, 3).<br><br>-define(TYPE_END_GROUP, 4).<br><br>-define(TYPE_32BIT, 5).<br></p><h6 id="0-TYPE-VARINT"><a href="#0-TYPE-VARINT" class="headerlink" title="0. TYPE_VARINT"></a>0. TYPE_VARINT</h6><p>程序在定义proto中用到的sint32 int32 uint64 bool enum 等都属于TYPE_VARINT 类型. 使用filedid + type + value 的方式来做。但是这并不表示value是定长的，其实pb用每个字节的第一个比特作为标识位，如果标识位为1，则下个字节就是属于这个value的，否则就不是。</p><h6 id="1-TYPE-64BIT-5-TYPE-32BIT"><a href="#1-TYPE-64BIT-5-TYPE-32BIT" class="headerlink" title="1.TYPE_64BIT  5.TYPE_32BIT"></a>1.TYPE_64BIT  5.TYPE_32BIT</h6><p>proto中用到的 fixed32，float属于TYPE_32BIT。fixed64，double 属于TYPE_32BIT. 使用filedid+type+value来做。其中value是定长的</p><h6 id="2-TYPE-STRING"><a href="#2-TYPE-STRING" class="headerlink" title="2. TYPE_STRING"></a>2. TYPE_STRING</h6><p>proto中用到的 string bytes 属于 TYPE_STRING. 使用filedid+type+len+value. 这样可以使得string不是定长的。其中len不是定长的，是用varint的方式来表示的。</p><h4 id="json-vs-protobuff"><a href="#json-vs-protobuff" class="headerlink" title="json vs protobuff"></a>json vs protobuff</h4><p>json很简单，json在未经压缩的情况下，是要比pb的包大的。<br><br>参考：<a href="https://google.github.io/flatbuffers/flatbuffers_benchmarks.html" target="_blank" rel="noopener">https://google.github.io/flatbuffers/flatbuffers_benchmarks.html</a></p><h3 id="2-编解码速度"><a href="#2-编解码速度" class="headerlink" title="2. 编解码速度"></a>2. 编解码速度</h3><p>参考：<a href="https://google.github.io/flatbuffers/flatbuffers_benchmarks.html" target="_blank" rel="noopener">https://google.github.io/flatbuffers/flatbuffers_benchmarks.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文讨论 protobuff 和 json 作为消息传递格式的优缺点。&lt;br&gt;&lt;br&gt;消息处理的过程包括：接收到二进制 -&amp;gt; 切包 -&amp;gt; 解码 -&amp;gt; 消息分发 -&amp;gt; 处理消息 &lt;br&gt;&lt;br&gt;所以我们决定从 1. 包的大小 2. 编解码速度 来讨论两者&lt;br&gt;
    
    </summary>
    
    
      <category term="protobuff" scheme="https://hongweikkx.github.io/tags/protobuff/"/>
    
      <category term="json" scheme="https://hongweikkx.github.io/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>golang  用函数名动态调用函数（包括变参函数)</title>
    <link href="https://hongweikkx.github.io/2018/08/24/golang-%E7%94%A8%E5%87%BD%E6%95%B0%E5%90%8D%E5%8A%A8%E6%80%81%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%88%E5%8C%85%E6%8B%AC%E5%8F%98%E5%8F%82%E5%87%BD%E6%95%B0/"/>
    <id>https://hongweikkx.github.io/2018/08/24/golang-用函数名动态调用函数（包括变参函数/</id>
    <published>2018-08-24T15:20:01.000Z</published>
    <updated>2018-08-24T15:23:35.613Z</updated>
    
    <content type="html"><![CDATA[<p><strong> golang  用函数名动态调用函数（包括变参函数）</strong> <br><br><a id="more"></a><br>以下Apply函数为动态调用的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">func main()&#123;</span><br><span class="line">      ret1 := Apply(Hello, []interface&#123;&#125;&#123;2,3&#125;)</span><br><span class="line">                  for _, v:= range ret1&#123;</span><br><span class="line">                           fmt.Println(v)</span><br><span class="line">                                 &#125;</span><br><span class="line">               ret2 := Apply(Format, []interface&#123;&#125;&#123;&quot;hello&quot;,44&#125;)</span><br><span class="line">                           for _, v:= range ret2&#123;</span><br><span class="line">                                    fmt.Println(v)</span><br><span class="line">                                          &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Apply(f interface&#123;&#125;, args []interface&#123;&#125;)([]reflect.Value)&#123;</span><br><span class="line">      fun := reflect.ValueOf(f)</span><br><span class="line">               in := make([]reflect.Value, len(args))</span><br><span class="line">                  for k,param := range args&#123;</span><br><span class="line">                           in[k] = reflect.ValueOf(param)</span><br><span class="line">                                 &#125;</span><br><span class="line">            r := fun.Call(in)</span><br><span class="line">                     return r</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 变参</span><br><span class="line">func Format(a ...interface&#123;&#125;) string&#123;</span><br><span class="line">      fmt.Println(a)</span><br><span class="line">            return &quot;format return&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func Hello(a int, b int)(int, string)&#123;</span><br><span class="line">      return a + b, &quot;hello&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong> 缺点：</strong>  不能够完美支持golang的多返回值。<br>只能通过 for range []reflect.value 来获得多返回值，<br>而不是可以  ret1, ret2 := Apply(f, args) 来接收多返回值</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; golang  用函数名动态调用函数（包括变参函数）&lt;/strong&gt; &lt;br&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://hongweikkx.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>动态规划、分治、贪心、递归</title>
    <link href="https://hongweikkx.github.io/2018/08/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%81%E5%88%86%E6%B2%BB%E3%80%81%E8%B4%AA%E5%BF%83%E3%80%81%E9%80%92%E5%BD%92/"/>
    <id>https://hongweikkx.github.io/2018/08/23/动态规划、分治、贪心、递归/</id>
    <published>2018-08-23T13:51:42.000Z</published>
    <updated>2018-08-23T14:04:21.952Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一言以蔽之"><a href="#一言以蔽之" class="headerlink" title="一言以蔽之:"></a>一言以蔽之:</h3><p>dp 和分治 之间的区别就在于是否有重叠子问题 ，如果有那就应该dp, 否则就应该分治。<br><br>当然如果可以每一步都产生最优解那么就不必dp了，贪心算法就可以了. <br><br>而递归只是一种实现算法的方法. <br><br> <a id="more"></a></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>下面分别用 dp， dc（分治法）， 贪心来做 leetcode 514. 自由之路<br><a href="https://leetcode-cn.com/problems/freedom-trail/description/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/freedom-trail/description/</a><br><br>golang 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">//ring := &quot;caotmcaataijjxi&quot;</span><br><span class="line">//key := &quot;oatjiioicitatajtijciocjc&quot;</span><br><span class="line">//ring := &quot;godding&quot;</span><br><span class="line">//key := &quot;gd&quot;</span><br><span class="line">ring := &quot;edcba&quot;</span><br><span class="line">key := &quot;abcde&quot;</span><br><span class="line">ret1 := findRotateStepsDp(ring, key)</span><br><span class="line">ret2 := findRotateStepsDc(ring, key)</span><br><span class="line">ret3 := findRotateStepsGreedy(ring, key)</span><br><span class="line">fmt.Println(ret1, ret2, ret3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ======================== 分治法 =================================</span><br><span class="line">// time limit</span><br><span class="line">// m:ring n:key</span><br><span class="line">// m 的n次方</span><br><span class="line">func findRotateStepsDc(ring string, key string) int &#123;</span><br><span class="line">l := len(key)</span><br><span class="line">return findmin(ring, 0, key, 0, l)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 从ring的s位置, key的i位置 所需要的最小值</span><br><span class="line">func findmin(ring string, s int, key string, i int, l int)int&#123;</span><br><span class="line">if i &gt;= l&#123;</span><br><span class="line">return 0</span><br><span class="line">&#125;</span><br><span class="line">min := math.MaxInt32</span><br><span class="line">temp := math.MaxInt32</span><br><span class="line">for j := range ring&#123;</span><br><span class="line">if ring[j] == key[i]&#123;</span><br><span class="line">temp = calc(s, j, len(ring)) + findmin(ring, j, key , i + 1, l)</span><br><span class="line">if temp &lt; min&#123;</span><br><span class="line">min = temp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return min</span><br><span class="line">&#125;</span><br><span class="line">//  ======================== dp ===========================</span><br><span class="line">// ac</span><br><span class="line">func findRotateStepsDp(ring string, key string) int &#123;</span><br><span class="line">dp := make([][100]int, 100)</span><br><span class="line">m := len(ring) - 1</span><br><span class="line">n := len(key) - 1</span><br><span class="line"></span><br><span class="line">for i := range key&#123;</span><br><span class="line">for j := range ring&#123;</span><br><span class="line">dp[i][j] = math.MaxInt32</span><br><span class="line">if ring[j] == key[i]&#123;</span><br><span class="line">if i == 0&#123;</span><br><span class="line">dp[i][j] = calc0(0, j, m)</span><br><span class="line"></span><br><span class="line">&#125;else&#123;</span><br><span class="line">dp[i][j] = calcmin(dp, i-1 , j, m)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ret := math.MaxInt32</span><br><span class="line">for i := 0; i &lt;= m; i++&#123;</span><br><span class="line">ret = min(ret, dp[n][i])</span><br><span class="line">&#125;</span><br><span class="line">return ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 要去dp(0, j) 位置 所需要的最小值</span><br><span class="line">func calc0(i int, j int, m int)int&#123;</span><br><span class="line">ret := calc(j,i,m + 1)</span><br><span class="line">return ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 要去 dp(i+1, j) 位置 所需的最小值</span><br><span class="line">func calcmin(dp [][100]int, i int, j int, ringl int) int&#123;</span><br><span class="line">ret := math.MaxInt32</span><br><span class="line">for k := 0; k &lt;= ringl; k++&#123;</span><br><span class="line">ret = min(dp[i][k] + calc(j, k, ringl + 1), ret)</span><br><span class="line">&#125;</span><br><span class="line">return ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ================================== greedy ===============================</span><br><span class="line">// 不能ac  因为不满足贪心选择</span><br><span class="line">func findRotateStepsGreedy(ring string, key string) int &#123;</span><br><span class="line">l := len(key)</span><br><span class="line">return findRotateStepsGreedyUtil(ring, 0, key, 0, l)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func  findRotateStepsGreedyUtil(ring string, start int, key string, i int, l int) int&#123;</span><br><span class="line">if i &gt;= l &#123;</span><br><span class="line">return 0</span><br><span class="line">&#125;</span><br><span class="line">count, nstart := findGreedy(ring, start, key, i)</span><br><span class="line">return  count + findRotateStepsGreedyUtil(ring, nstart, key, i+1, l)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func findGreedy(ring string, start int, key string, i int)(int, int)&#123;</span><br><span class="line">c := math.MaxInt32</span><br><span class="line">ctemp := math.MaxInt32</span><br><span class="line">l := len(ring)</span><br><span class="line">ret := start</span><br><span class="line">for k := range ring&#123;</span><br><span class="line">if ring[k] == key[i]&#123;</span><br><span class="line">ctemp = min(calc(start, k, l), c)</span><br><span class="line">if c != ctemp&#123;</span><br><span class="line">c = ctemp</span><br><span class="line">ret = k</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return c, ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// -----------------  common func ----------------------</span><br><span class="line">// a,b 最小值</span><br><span class="line">func min(a int, b int) int&#123;</span><br><span class="line">if a &lt; b&#123;</span><br><span class="line">return a</span><br><span class="line">&#125;</span><br><span class="line">return b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ring中 s 到mid 的最小距离</span><br><span class="line">func calc(s int, e int, l int) int&#123;</span><br><span class="line">a := 0</span><br><span class="line">b := 0</span><br><span class="line">if s &gt;= e&#123;</span><br><span class="line">a = s - e</span><br><span class="line">b = l - a</span><br><span class="line">return min(a, b) + 1</span><br><span class="line">&#125;else&#123;</span><br><span class="line">a = e - s</span><br><span class="line">b = l - a</span><br><span class="line">return min(a, b) + 1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一言以蔽之&quot;&gt;&lt;a href=&quot;#一言以蔽之&quot; class=&quot;headerlink&quot; title=&quot;一言以蔽之:&quot;&gt;&lt;/a&gt;一言以蔽之:&lt;/h3&gt;&lt;p&gt;dp 和分治 之间的区别就在于是否有重叠子问题 ，如果有那就应该dp, 否则就应该分治。&lt;br&gt;&lt;br&gt;当然如果可以每一步都产生最优解那么就不必dp了，贪心算法就可以了. &lt;br&gt;&lt;br&gt;而递归只是一种实现算法的方法. &lt;br&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://hongweikkx.github.io/tags/golang/"/>
    
      <category term="算法" scheme="https://hongweikkx.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>hibernate and why gen_server2?</title>
    <link href="https://hongweikkx.github.io/2018/07/28/hibernate-and-why-gen-server2/"/>
    <id>https://hongweikkx.github.io/2018/07/28/hibernate-and-why-gen-server2/</id>
    <published>2018-07-28T06:54:17.000Z</published>
    <updated>2018-07-28T07:04:28.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hibernate-休眠"><a href="#hibernate-休眠" class="headerlink" title="hibernate - 休眠"></a>hibernate - 休眠</h2><h4 id="1-描述："><a href="#1-描述：" class="headerlink" title="1. 描述："></a>1. 描述：</h4><p>&#8194;&#8194;&#8194; 使进程进入一个最小内存分配的等待状态。 如果这个进程并没有期望近期接收任何消息， 那么这个状态是有用的。<br><a id="more"></a></p><h4 id="2-行为："><a href="#2-行为：" class="headerlink" title="2. 行为："></a>2. 行为：</h4><ul><li>会丢掉进程调用栈，然后 进行gc。 这样所有的活数据就会在一个连续的堆中。 这个堆大小几近相当于所有活数据的大小（即便这个大小小于最小进程堆大小） .  如果所有活数据大小小于最小进程堆大小的话，在醒来后就会发生一次gc，用于保证进程堆大小不小于最小进程堆大小. 所以hibernate 可能触发了两次gc,一次是休眠的时候(必然) ,另一次是醒来不久(可能)。 这个是很耗cpu的，所以一般不会主动做这件事情。   </li><li>catch 也会被清除， 所以必须在醒来的时候重新插入。 直接或者间接用proc_lib 开始的进程（包括<code>gen_server</code>)， 要用<code>proc_lib:hibernate/3</code> 来确保 异常处理程序在醒来的时候能够继续工作   </li><li>控制会在指定参数的<code>module:function</code>，调用栈为空的情况下恢复， 意味着这个函数返回的时候，进程就终止了,所以<code>erlang:hibernate/3</code> 不返回任何东西给调用者。 </li><li>wake up: <ul><li>只要有信息发送到进程，该进程就会醒来。</li><li>如果消息邮箱有任何信息， 该进程也会立马醒来</li></ul></li></ul><h2 id="gen-server2"><a href="#gen-server2" class="headerlink" title="gen_server2"></a>gen_server2</h2><h4 id="init-函数"><a href="#init-函数" class="headerlink" title="init 函数"></a>init 函数</h4><p>&#8194;&#8194;&#8194; init 函数可以返回第4个参数, <code>{backoff, InitalTimeout, MinimumTimeout, DesiredHibernatePeriod}</code>，这样就设置为backoff 模式， 这里所有的参数都是毫秒级，infinity 在这里是无意义的。<br><br>&#8194;&#8194;&#8194; 之后所有能够返回timeout的回调模块（包括init），timeout后都会hibernate。 在这个模式中， 当前的timeout将会被用来另做他用。 初始值是由InitalTimeout 决定的。 当这次timeout后，就会进入休眠。 在醒来之后，新的timeout值将会被计算出来。<br><br>&#8194;&#8194;&#8194; 这样做的目的是, gen_server2 可以调整现在的timeout 值，如果不能在DesiredHibernatePeriod 休眠的话， timeout 值将会重复增加。如果在期间休眠的话， timeout值将会减少成最小的值。 这样可以使得进程更快的投入休眠（而且期望待在睡眠状态很久）。 简单的说就是， 如果一个进程接收到一大堆消息， 那么他就应该在这些消息中间，不进行睡眠。 但是如果消息变得稀少， 进程不仅仅会休眠， 而且也会很快的休眠。</p><h4 id="backoff-模式-timeout"><a href="#backoff-模式-timeout" class="headerlink" title="backoff 模式 timeout"></a>backoff 模式 timeout</h4><p>&#8194;&#8194;&#8194; 当使用backoff 模式, 但是没有设置hiberbnate的时候， 正常的timeout值仍然可以被使用， <code>handle_info(timeout, State)</code> 也会被正常调用。<br>&#8194;&#8194;&#8194; 在backoff 模式下， 如果<code>handle_info(timeout, State)</code>函数中返回hibernate， 将不会立即休眠，相反，将会等待休眠的timeout 才会休眠。 </p><h4 id="优先级消息"><a href="#优先级消息" class="headerlink" title="优先级消息"></a>优先级消息</h4><p>&#8194;&#8194;&#8194; 回调模块可以可选的实现 优先级消息。 高优先级的会优先选择执行</p><h4 id="更加有效率的选择性接收，-更小的可能去扫描一个大的消息队列"><a href="#更加有效率的选择性接收，-更小的可能去扫描一个大的消息队列" class="headerlink" title="更加有效率的选择性接收， 更小的可能去扫描一个大的消息队列"></a>更加有效率的选择性接收， 更小的可能去扫描一个大的消息队列</h4><ol><li>不断的从进程邮箱中读取消息，放入优先级队列中去</li><li>如果有消息， 通过优先级队列,处理最大优先级执行的消息,<br> &#8194;如果返回hibernate 并且不是backoff，先调用pre_hibernate ，再调用<code>proc_lib:hibernate</code>， 醒来时receive所有message, 加到Queue里，再调用post_hibernate，然后处理Queue里的message<br>  否则继续loop 1 </li><li>如果处理时发现优先级队列为空，<ul><li>如果有hibernate,也有backoff, 直接去receive,然后加到Queue,如果timeout，去call pre_hibernate, hibernate,wake 以后重新调整timeout。</li><li>如果有hibernate，没有backoff, 将timeout设成 infinity， 在那一直去receive（边睡边等）</li><li>如果没有hibernate, 直接去receive，然后加到Queue。如果timeout, 就由handle_info来处理</li></ul></li></ol><h4 id="handle-pre-hibernate-and-handle-post-hibernate"><a href="#handle-pre-hibernate-and-handle-post-hibernate" class="headerlink" title="handle_pre_hibernate and handle_post_hibernate"></a>handle_pre_hibernate and handle_post_hibernate</h4><p>&#8194;&#8194;&#8194;回调模块可以可选的实现 <code>handle_pre_hibernate/1</code> and <code>handle_post_hibernate</code>. <br><br>&#8194;&#8194;&#8194;如果<code>handle_pre_hibernate/1</code> 返回 {hibernate, NewState} ， 进程将会休眠。<br><br>&#8194;&#8194;&#8194;如果模块没有实现 <code>handle_pre_hibernate/1</code>, 那么接下来默认的行为将会是 hibernate</p><h4 id="gen-server2-cast-是保证顺序的。"><a href="#gen-server2-cast-是保证顺序的。" class="headerlink" title="gen_server2:cast 是保证顺序的。"></a>gen_server2:cast 是保证顺序的。</h4><p>   原始的代码可能在与当前未连接的远程进程通信的时候，重新对消息排序。 因为会spawn进程 这样的话会导致消息发送排序不是原来的顺序.  gen_server2 去掉了 send 函数的 noconnect 参数,  不会在与当前未连接的远程进程通信的时候spawn</p><h4 id="become-Module-State"><a href="#become-Module-State" class="headerlink" title="{become,Module,State}"></a>{become,Module,State}</h4><p>&#8194;&#8194;&#8194; 所有的回调都可以返回{become,Module,State} 或者 {become, Module, State, Timeout} 这个可以允许gen_server动态改变自己的callback 模块。 State是新 state<br>&#8194;&#8194;&#8194;注意，这里没有一种形式可以包括一个reply， 所以你需要手动reply。 init 函数也可以相似的返回一个第五个参数， module， 为了动态决定用哪个callback module 去init</p><h4 id="format-message-queue-2"><a href="#format-message-queue-2" class="headerlink" title="format_message_queue/2"></a>format_message_queue/2</h4><p>&#8194;&#8194;&#8194;callback module 可以定制化实现 <code>format_message_queue/2</code> 就类似于 <code>format_status/2</code>, 但是他的第二个参数是优先级队列， 包含优先级消息队列</p><h4 id="with-state-2"><a href="#with-state-2" class="headerlink" title="with_state/2"></a>with_state/2</h4><h4 id="multi-call"><a href="#multi-call" class="headerlink" title="multi_call"></a>multi_call</h4><p>&#8194;&#8194;&#8194;mcall 函数增加了性能更好的并行multi_call。 multi_call 发送相同的请求给列表中相同名字的进程。 他在name/request 对上操作， 名称可以是任何被call/3 接收的参数。<br><br>&#8194;&#8194;&#8194; 两个的机制不同，mcall 只是起了一个monitor 在新进程中 给每一个请求列表中的进程发送消息， 将ref存储在dict中，并接收返回。 返回成功后 返回原进程消息。 <br><br>&#8194;&#8194;&#8194;mutlti_call 每个消息建立一个进程， 然后接收返回（先发送的要先接受) 两秒后如果接收不到 就不成功）。  </p><h2 id="why-gen-server2"><a href="#why-gen-server2" class="headerlink" title="why gen_server2?"></a>why gen_server2?</h2><ol><li>gen_server2 通过优先级队列， 防止了进程需要遍历整个邮箱的可能</li><li>实现了消息优先级</li><li>hibernate 退避机制</li></ol><p>其实我并没有遇到需要优化gen_server 到 gen_server2的项目， 有点纸上谈兵。 不过理解gen_server2 也让我了解了gen_server 的一些“缺点”， 毕竟需要根据项目定制， 就说明原本的gen_server 在那个项目中是有使用”缺陷”的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;hibernate-休眠&quot;&gt;&lt;a href=&quot;#hibernate-休眠&quot; class=&quot;headerlink&quot; title=&quot;hibernate - 休眠&quot;&gt;&lt;/a&gt;hibernate - 休眠&lt;/h2&gt;&lt;h4 id=&quot;1-描述：&quot;&gt;&lt;a href=&quot;#1-描述：&quot; class=&quot;headerlink&quot; title=&quot;1. 描述：&quot;&gt;&lt;/a&gt;1. 描述：&lt;/h4&gt;&lt;p&gt;&amp;#8194;&amp;#8194;&amp;#8194; 使进程进入一个最小内存分配的等待状态。 如果这个进程并没有期望近期接收任何消息， 那么这个状态是有用的。&lt;br&gt;
    
    </summary>
    
    
      <category term="erlang" scheme="https://hongweikkx.github.io/tags/erlang/"/>
    
      <category term="性能优化" scheme="https://hongweikkx.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Heap-Architectures-for-Concurrent-Languages-using-Message-Passing</title>
    <link href="https://hongweikkx.github.io/2018/07/21/Heap-Architectures-for-Concurrent-Languages-using-Message-Passing/"/>
    <id>https://hongweikkx.github.io/2018/07/21/Heap-Architectures-for-Concurrent-Languages-using-Message-Passing/</id>
    <published>2018-07-20T17:58:24.000Z</published>
    <updated>2018-07-20T18:32:33.690Z</updated>
    
    <content type="html"><![CDATA[<p>设计并发语言的一个难点就在于运行时系统中存储结构的实现，<br>这里将讨论 依赖自动内存回收和通过异步消息传递实现并发的语言的运行时系统实现<br><a id="more"></a></p><p>有三种可选择的内存堆结构。<br></p><ol><li>每个进程分配和管理自己的内存区域， 所有在进程间的消息都必须拷贝。<br></li><li>有一个所有进程都共享的堆 <br></li><li>一个混合的架构, 每个进程有自己的私有堆，同时有一个共享的堆用于类似于消息的数据发送.</li></ol><p>接下来将对于每种体系结构，讨论进程间消息传递和gc </p><h3 id="1-以进程为中心的体系结构"><a href="#1-以进程为中心的体系结构" class="headerlink" title="1. 以进程为中心的体系结构"></a>1. 以进程为中心的体系结构</h3><h4 id="1-1-描述"><a href="#1-1-描述" class="headerlink" title="1.1 描述"></a>1.1 描述</h4><p>   堆和栈 放在一起。 好处是容易判断溢出，坏处是扩展或者重新分配堆或者栈涉及到了相同的区域。 <br><br>   erlang支持大型的binary，他们并没有存储在堆中，而是引用计数的存储在一个分离的全局内存区域. 因此此后，我们将忽略大型的对象。 </p><h4 id="1-2-进程消息传递"><a href="#1-2-进程消息传递" class="headerlink" title="1.2 进程消息传递:"></a>1.2 进程消息传递:</h4><p>   本地数据发送到另一个进程 会被扁平化， 所以会占据更多的空间。<br>   erlang exp:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1&gt; L = [1,2,3].</span><br><span class="line">[1,2,3]</span><br><span class="line"></span><br><span class="line">2&gt; L1 = [L, L, L].</span><br><span class="line">[[1,2,3],[1,2,3],[1,2,3]]</span><br><span class="line"></span><br><span class="line">3&gt; erts_debug:size(L1).</span><br><span class="line">12</span><br><span class="line">4&gt; erts_debug:flat_size(L1).</span><br><span class="line">24</span><br><span class="line">5&gt; Pid = spawn(fun() -&gt; receive E -&gt; io:format(&quot;~p~n&quot;, [erts_debug:size(E)]) end end).</span><br><span class="line">&lt;0.66.0&gt;</span><br><span class="line">6&gt; Pid ! L1.</span><br><span class="line">24</span><br><span class="line">[[1,2,3],[1,2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><h4 id="1-3-gc"><a href="#1-3-gc" class="headerlink" title="1.3 gc"></a>1.3 gc</h4><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：<br></h5><p>   <strong>1. 内存回收无成本</strong> <br><br>   进程死去内存会直接释放掉， 不需要gc. <br><br>   <strong>2. 小的根集合</strong> <br><br>   每个程序都有自己的堆， 那么栈和邮箱的根集合就会很小， gc时间短。 <br><br>   <strong>3. 缓存局部性的提高</strong><br><br>      缓存局部性是指程序在执行某个程序的时候， 倾向于使用最近使用（时间局部性）或者附近的数据（空间局部性）.因为每个进程的数据都在一个连续的而且小的堆栈空间中， 所以内存的局部性也是很好的。<br><br>   <strong>4. 堆栈溢出更加容易检测</strong><br><br>   因为每个进程一个堆，堆和栈的溢出的测试可以放在一起，更少的去访问寄存器中的指针</p><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>   <strong>1. 消息传递花销大</strong> <br><br>     消息在传递是必须复制，而且扁平化处理。在一些实现中，消息可能需要遍历不止一次，一次用于计算大小， （用于接收堆溢出的检测，或者触发gc 或者 在必要的时候扩展）， 另一次用于复制。<br><br>   <strong>2. 更多的空间需要</strong> <br><br>    因为消息是复制的。 如果这个消息中包含很多相似的子term，那么在消息发送的时候将会非线性的增长。而且，子term如果在两个进程间来回传送的时候，哪怕term之前在这个进程已经存在了, 每一个发送也都会有一个新的copy。<br><br>   <strong>3. 高内存碎片</strong> <br><br>    因为进程不能利用其它进程的内存空间， 即便其他进程有没有使用的空间。 这也就是说一个进程默认只能使用一小部分的内存， 这也反过来增加了gc的次数。</p><p>   这种架构会影响程序改怎么写。比如erlang要求小消息，大运算。</p><h3 id="2-一个分享堆的体系结构"><a href="#2-一个分享堆的体系结构" class="headerlink" title="2.一个分享堆的体系结构"></a>2.一个分享堆的体系结构</h3><h4 id="2-1-描述"><a href="#2-1-描述" class="headerlink" title="2.1 描述"></a>2.1 描述</h4><p>   在这个体系结构中， 每个进程都有自己的栈，但是只有一个供所有进程共享的唯一的堆。这个堆 共享消息和所有复合的terms。</p><h4 id="2-2-进程消息传递："><a href="#2-2-进程消息传递：" class="headerlink" title="2.2 进程消息传递："></a>2.2 进程消息传递：</h4><p>   消息传递只需要传递一个指针, 共享的堆也保持不变，消息也不需要拷贝和遍历。 在这个结构中， 消息传递是一个常量操作。</p><h4 id="2-3-gc"><a href="#2-3-gc" class="headerlink" title="2.3 gc"></a>2.3 gc</h4><p>   从概念上来讲，共享堆的gc操作和私有堆应该是一样的，不同的是共享堆的根集（root set）包括了所有进程的栈和邮箱；这些进程会迫使gc. 这表明了，即使是在一个多线程的系统中， gc也会阻塞所有的进程。</p><h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><p>   <strong>1. 更快的消息传递</strong> <br><br>    因为消息传递只涉及到了更新一个指针；这个操作是独立于消息大小的<br><br>   <strong>2. 更少的空间需要</strong> <br><br>   因为数据的传送是共享在全局堆的， 所有的内存需要是少于独立堆系统的。<br><br>   <strong>3. 低内存碎片</strong> <br><br>   共享堆的整个内存在任意进程都是有用的。</p><h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><p>   <strong>1. 更大的根set 一旦gc发生， 所有的进程都会阻塞</strong> <br><br>   <strong>2. 更大的空间</strong> <br><br>    拷贝空间和正在gc的空间一样大。 预计这个会比单独gc要大。<br><br>   <strong>3. 更多的gc时间</strong> <br><br>   当拷贝收集器使用的时候， 所有实时数据将会被移动。在极端情况下，一个拥有很多可达数据的将要死亡的睡眠进程将会影响整个系统的gc时间。而在私有堆系统中，在gc时，只有强制gc的实时数据才会被移动。<br><br>   <strong>4. 堆和栈的溢出测试将是分开的 而且需要更昂贵的测试</strong></p><p>   两种内存结构的差异也值得一提：在进程为中心的系统中， 更容易对特定的进程使用某种空间资源上 限制。 如果在共享的系统中，这个实现将会很复杂而且花销也很大。 </p><h4 id="2-4-优化"><a href="#2-4-优化" class="headerlink" title="2.4 优化"></a>2.4 优化</h4><p>   优化：根集大 很大程度可以通过一些简单的优化来弥补。 在频繁的小型gc中，根集应该只包括在上次gc后，这些进程接触过的数据。<br>   因为每一个进程都有自己的栈， 很容易维持一个安全的近似值， 这个值是自从上次gc后， 活动进程的root set。</p><p>   更精进一点就是 通过 generational stack collection 技术来减少根集的大小。 期望对于每个自从上次gc后活跃的进程的整个栈 不会被扫描多次。 注意：这是对所有内存体系结构都适用的优化。</p><p>   最后， 不得不移动睡眠进程的活跃数据的问题，可以通过为旧的一代垃圾采用非移动的gc收集器来解决。</p><h3 id="3-一个同时有私有堆和共享消息区域的体系结构"><a href="#3-一个同时有私有堆和共享消息区域的体系结构" class="headerlink" title="3. 一个同时有私有堆和共享消息区域的体系结构"></a>3. 一个同时有私有堆和共享消息区域的体系结构</h3><h4 id="3-1-描述"><a href="#3-1-描述" class="headerlink" title="3.1 描述"></a>3.1 描述</h4><p>   为了使得收集私有堆垃圾的时候不涉及到公共领域，在gc的时候不阻塞其他的进程，不应该有任何一个指针从共享区域指向进程的堆。 从私有堆或者栈 到 共享区域的指针是允许的。 </p><h4 id="3-2-分配策略"><a href="#3-2-分配策略" class="headerlink" title="3.2 分配策略"></a>3.2 分配策略</h4><p>这个结构要求我们知道哪些数据是进程独有的，哪些是将被发送的消息（共享）。我们希望这些信息是在编译期间是可用的，能够通过程序员手动声明或者使用逃逸分析自动获得。<br><br>这些程序先前已经开发出来用于函数式语言的数据结构的栈分配. 但类似于单独编译，动态链接库，或者其他语言的结构（比如erlang允许动态更新指定模块的代码）， 可能在实际中使得这样的分析不准确。因此，这样依靠分析混合系统，必须能够处理不精确的逃逸信息.<br><br>    具体的来讲：逃逸分析应该返回的信息是:<br><br>    一个特定的程序指针是属于进程本地类型，还是进程逃逸（ie：消息的一部分）， 或者是未知类型（可能会被当成消息）。 这个系统应该决定在哪里放置未知类型的数据. <br><br>    如果在进程本地堆放置未知数据类型，那么每次发送操作都需要测试，是否这个消息参数在本地堆还是在消息区域。这种设计最小化了共享的消息区域。 但如果是消息数据必须从本地堆拷贝到消息区域， 将拥有消息拷贝的所有缺点。<br><br>    如果在全局区域放置未知数据类型， 传递消息只需要传递一个指针就好了。 这样做的缺点是，只是进程本地的数据也还会有可能用尽共享内存， 从而引发gc</p><h4 id="3-3-进程消息传递："><a href="#3-3-进程消息传递：" class="headerlink" title="3.3 进程消息传递："></a>3.3 进程消息传递：</h4><p>消息传递发生在共享的堆区域，是一个常量操作。 值得注意的是， 如果一份数据，实际上是消息，但是没有被逃逸分析出来，他必须先从进程堆拷贝共享堆</p><h4 id="3-4-gc"><a href="#3-4-gc" class="headerlink" title="3.4 gc"></a>3.4 gc</h4><p>因为不存在一个指针从共享区域指向进程的堆， 也不允许其他进程指向。 本地gc能够独立于其他进程发生， 也不需要阻塞整个系统。 这个和gc总是搜集共享区域，因而要求锁的系统不同。<br></p><p>在这个系统中，gc共享消息区域是要求同步的。为了避免 重复遍历长寿命的消息 和避免不得不更新私有进程指针,共享内存或者仅仅是老的一代可以通过非移动的标记-清除收集器来搜集。 这种搜集器相比于拷贝搜集器有其他的优势， 就是很容易增量制作（也因此并发）。另外一种可选的方案是引用计数。，平常的引用计数的缺点在我们这里不是问题， 因为在消息区域没有循环引用。</p><h5 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h5><p>   <strong>1. 快速的消息传递</strong> <br><br>   <strong>2. 少的空间需求。 消息共享</strong> <br><br>   <strong>3. 无成本内存回收， 当一个进程死亡， 他的堆和栈能够直接释放掉， 而不需要gc</strong> <br><br>   <strong>4. 本地搜集器有小的根集。 因为每个进程都有自己的堆。</strong> <br><br>   <strong>5. 简单的堆栈溢出测试</strong> <br></p><h5 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h5><p>   <strong>1. 内存碎片</strong> <br><br>   <strong>2. 消息区域有大的根集。</strong><br>    共享区域需要检测所有的进程栈和本地堆， 因为gc很昂贵。 在最坏的情况下， gc的花费和共享堆系统花费应该是一样大的。但是，因为在程序运行期间，消息一般只占用一小部分的数据结构， 而且这个共享区域是相当大的， 所以这种大型gc不会很频繁。 更进一步， 根基可以通过在第四节描述的方法来进一步减少。<br><br>   <strong>3. 要求逃逸分析</strong><br>   系统的表现取决于分析的准确性</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>更多内容：<a href="http://www.fantasi.se/publications/ISMM02.pdf" target="_blank" rel="noopener">Heap Architectures for Concurrent Languages using Message Passing</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计并发语言的一个难点就在于运行时系统中存储结构的实现，&lt;br&gt;这里将讨论 依赖自动内存回收和通过异步消息传递实现并发的语言的运行时系统实现&lt;br&gt;
    
    </summary>
    
    
      <category term="architectures" scheme="https://hongweikkx.github.io/tags/architectures/"/>
    
      <category term="erlang" scheme="https://hongweikkx.github.io/tags/erlang/"/>
    
  </entry>
  
  <entry>
    <title>读取.csv文件为.erl文件</title>
    <link href="https://hongweikkx.github.io/2018/07/14/%E8%AF%BB%E5%8F%96-csv%E6%96%87%E4%BB%B6%E4%B8%BA-erl%E6%96%87%E4%BB%B6/"/>
    <id>https://hongweikkx.github.io/2018/07/14/读取-csv文件为-erl文件/</id>
    <published>2018-07-14T14:25:25.000Z</published>
    <updated>2018-07-17T16:22:08.860Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-功能描述"><a href="#1-功能描述" class="headerlink" title="1. 功能描述"></a>1. 功能描述</h4><p>erlang游戏服务器经常会用到的一个功能模块就是将策划配置的.csv文件改写成 .erl 文件。所以我把这个功能单独写成了一个服务。<br><a id="more"></a></p><h4 id="2-服务git地址为"><a href="#2-服务git地址为" class="headerlink" title="2. 服务git地址为"></a>2. 服务git地址为</h4><p> <a href="https://github.com/hongweikkx/csv2erl.git" target="_blank" rel="noopener">https://github.com/hongweikkx/csv2erl.git</a></p><h4 id="3-功能效果："><a href="#3-功能效果：" class="headerlink" title="3. 功能效果："></a>3. 功能效果：</h4><p>.csv 文件<br><code>cat hero.csv</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hero_id,hero_name</span><br><span class="line">英雄id,英雄名字</span><br><span class="line">int,string</span><br><span class="line">1001,貂蝉</span><br><span class="line">1002,甄姬</span><br></pre></td></tr></table></figure></p><p>=&gt; .erl 文件<br><code>cat hero.erl</code><br><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-module</span><span class="params">(hero)</span>.</span><br><span class="line"><span class="keyword">-export</span><span class="params">([get/<span class="number">1</span>, get_all/<span class="number">0</span>])</span>.</span><br><span class="line"><span class="keyword">-include</span><span class="params">(<span class="string">"table_to_data_record.hrl"</span>)</span>.</span><br><span class="line"><span class="function"><span class="title">get</span><span class="params">(<span class="number">1001</span>)</span> -&gt;</span></span><br><span class="line">#data_hero&#123;</span><br><span class="line">hero_id = <span class="number">1001</span>,</span><br><span class="line">hero_name = [<span class="number">232</span>,<span class="number">178</span>,<span class="number">130</span>,<span class="number">232</span>,<span class="number">157</span>,<span class="number">137</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="title">get</span><span class="params">(<span class="number">1002</span>)</span> -&gt;</span></span><br><span class="line">#data_hero&#123;</span><br><span class="line">hero_id = <span class="number">1002</span>,</span><br><span class="line">hero_name = [<span class="number">231</span>,<span class="number">148</span>,<span class="number">132</span>,<span class="number">229</span>,<span class="number">167</span>,<span class="number">172</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="title">get</span><span class="params">(_)</span> -&gt;</span> not_find.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">get_all</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    [<span class="number">1001</span>,<span class="number">1002</span>].</span><br></pre></td></tr></table></figure></p><hr><p><em>best wishes</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-功能描述&quot;&gt;&lt;a href=&quot;#1-功能描述&quot; class=&quot;headerlink&quot; title=&quot;1. 功能描述&quot;&gt;&lt;/a&gt;1. 功能描述&lt;/h4&gt;&lt;p&gt;erlang游戏服务器经常会用到的一个功能模块就是将策划配置的.csv文件改写成 .erl 文件。所以我把这个功能单独写成了一个服务。&lt;br&gt;
    
    </summary>
    
    
      <category term="erlang" scheme="https://hongweikkx.github.io/tags/erlang/"/>
    
      <category term="csv" scheme="https://hongweikkx.github.io/tags/csv/"/>
    
  </entry>
  
  <entry>
    <title>erl&lt;=&gt;abstract_code</title>
    <link href="https://hongweikkx.github.io/2018/07/14/erl-abstract-code/"/>
    <id>https://hongweikkx.github.io/2018/07/14/erl-abstract-code/</id>
    <published>2018-07-14T14:19:51.000Z</published>
    <updated>2018-07-17T16:23:39.594Z</updated>
    
    <content type="html"><![CDATA[<h5 id="erl-gt-abstract-code"><a href="#erl-gt-abstract-code" class="headerlink" title="erl =&gt; abstract_code"></a>erl =&gt; abstract_code</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">erlc +debug_info test.erl</span><br><span class="line">&#123;ok, &#123;_, [&#123;abstract_code, &#123;_, Abs&#125;&#125;]&#125;&#125; = beam_lib:chunks(test, [abstract_code]).</span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="abstract-code-gt-erl"><a href="#abstract-code-gt-erl" class="headerlink" title="abstract_code =&gt; erl"></a>abstract_code =&gt; erl</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S = erl_prettypr:format(erl_syntax:form_list(Abs)).</span><br><span class="line">file:write_file(&quot;test_code&quot;, term_to_binary(S)).</span><br></pre></td></tr></table></figure><h5 id="ep"><a href="#ep" class="headerlink" title="ep:"></a>ep:</h5><h5 id="erl-gt-abstract-code-1"><a href="#erl-gt-abstract-code-1" class="headerlink" title="erl =&gt; abstract_code"></a>erl =&gt; abstract_code</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.erl</span><br><span class="line">-module(test).</span><br><span class="line">-export([start/0]).</span><br><span class="line">-ifdef(TEST).</span><br><span class="line">hello() -&gt;</span><br><span class="line">   io:format(&quot;########1~n&quot;).</span><br><span class="line">-else.</span><br><span class="line">hello() -&gt;</span><br><span class="line">   io:format(&quot;########2&quot;).</span><br><span class="line">-endif.</span><br><span class="line">start() -&gt;</span><br><span class="line">   hello().</span><br><span class="line">$</span><br><span class="line">$ erlc +debug_info test.erl</span><br><span class="line">$ erl</span><br><span class="line">1&gt; &#123;ok, &#123;_, [&#123;abstract_code, &#123;_, Abs&#125;&#125;]&#125;&#125;=beam_lib:chunks(test, [abstract_code                                 ]).</span><br><span class="line">&#123;ok,&#123;test,</span><br><span class="line">        [&#123;abstract_code,</span><br><span class="line">             &#123;raw_abstract_v1,</span><br><span class="line">                 [&#123;attribute,1,file,&#123;&quot;c:/Users/4399/Desktop/test.erl&quot;,1&#125;&#125;,</span><br><span class="line">                  &#123;attribute,1,module,test&#125;,</span><br><span class="line">                  &#123;attribute,2,export,[&#123;start,0&#125;]&#125;,</span><br><span class="line">                  &#123;function,7,hello,0,</span><br><span class="line">                      [&#123;clause,7,[],[],[&#123;call,8,&#123;remote,...&#125;,[...]&#125;]&#125;]&#125;,</span><br><span class="line">                  &#123;function,11,start,0,</span><br><span class="line">                      [&#123;clause,11,[],[],[&#123;call,12,&#123;...&#125;,...&#125;]&#125;]&#125;,</span><br><span class="line">                  &#123;eof,15&#125;]&#125;&#125;]&#125;&#125;</span><br></pre></td></tr></table></figure><h5 id="abstract-code-gt-erl-1"><a href="#abstract-code-gt-erl-1" class="headerlink" title="abstract_code =&gt; erl"></a>abstract_code =&gt; erl</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2&gt; S = erl_prettypr:format(erl_syntax:form_list(Abs)).</span><br><span class="line">&quot;-file(\&quot;c:/Users/4399/Desktop/test.erl\&quot;, 1).\n\n-module(test).\n\n-export([sta                                 rt/0]).\n\nhello() -&gt; io:format(\&quot;########2\&quot;).\n\nstart() -&gt; hello().\n\n&quot;</span><br><span class="line">3&gt; file:write_file(&quot;test_code&quot;, term_to_binary(S)).</span><br><span class="line">ok</span><br><span class="line">$ cat test_code</span><br><span class="line">僰▒-file(&quot;c:/Users/4399/Desktop/test.erl&quot;, 1).</span><br><span class="line"></span><br><span class="line">-module(test).</span><br><span class="line"></span><br><span class="line">-export([start/0]).</span><br><span class="line"></span><br><span class="line">hello() -&gt; io:format(&quot;########2&quot;).</span><br><span class="line"></span><br><span class="line">start() -&gt; hello().</span><br></pre></td></tr></table></figure><hr><p><em>best wishes</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;erl-gt-abstract-code&quot;&gt;&lt;a href=&quot;#erl-gt-abstract-code&quot; class=&quot;headerlink&quot; title=&quot;erl =&amp;gt; abstract_code&quot;&gt;&lt;/a&gt;erl =&amp;gt; abstract_code&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;erlc +debug_info test.erl&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;ok, &amp;#123;_, [&amp;#123;abstract_code, &amp;#123;_, Abs&amp;#125;&amp;#125;]&amp;#125;&amp;#125; = beam_lib:chunks(test, [abstract_code]).&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="erlang" scheme="https://hongweikkx.github.io/tags/erlang/"/>
    
  </entry>
  
  <entry>
    <title>erlang 热更新原理</title>
    <link href="https://hongweikkx.github.io/2018/07/13/erlang-%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://hongweikkx.github.io/2018/07/13/erlang-热更新原理/</id>
    <published>2018-07-13T15:10:12.000Z</published>
    <updated>2018-07-17T16:25:23.979Z</updated>
    
    <content type="html"><![CDATA[<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>调用一个 未加载的文件或者显示的code:load_file/1 函数调用的时候都会 触发erlang代码服务器动态加载代码</p><h2 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h2><p>当内存中的程序需要更新的时候， erlang VM 会维持两个版本， 一个是老版本 old , 一个是新版本 new.  热更新时，驻留在旧代码中的执行会继续执行旧的代码而其他情况下执行新的代码。<br><a id="more"></a><br>具体是：当函数调用为非限定调用的时候就使用旧代码， 而在使用M:F(A) 完全限定调用的时候， 就使用新的代码。<br>这个时候就会出现几个问题， </p><ol><li>如果一直调用local 代码是不是就一直不更新了？ </li><li>如果代码连续修改了两次，现在内存中就会有三个版本v(1) v(2) v(3)， 那么如果最初的版本v(1)还在执行会被怎么处理？</li></ol><p>用下面的代码来测试一下（代码来自elrang 编程指南）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-module(mod_test).</span><br><span class="line">-export([main/0, loop/0, cal/1, do/1]).</span><br><span class="line">main() -&gt;</span><br><span class="line">   register(foo, spawn(mod_test, loop,[])).</span><br><span class="line">  </span><br><span class="line">loop() -&gt;</span><br><span class="line">   receive</span><br><span class="line">      &#123;Sender, X&#125; -&gt;</span><br><span class="line">      Sender ! &#123;self(),cal(X)&#125;</span><br><span class="line">   end,</span><br><span class="line">   loop().</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">do(X) -&gt;</span><br><span class="line">    foo ! &#123;self(),X&#125;,</span><br><span class="line">    receive </span><br><span class="line">      &#123;_, Y&#125; -&gt;</span><br><span class="line">         Y</span><br><span class="line">    end.</span><br><span class="line">cal(X) -&gt;</span><br><span class="line">    X + 1.</span><br></pre></td></tr></table></figure><blockquote><p>1&gt; c(mod_test).</p><p>{ok,mod_test}</p><p>2&gt; mod_test:main().</p><p>true</p><p>3&gt; mod_test:do(1).</p><p>2</p></blockquote><p>之后修改cal(X) -&gt; X + 2.重新在原来的终端上编译</p><blockquote><p>4&gt; c(mod_test)</p><p>{ok,mod_test}</p><p>5&gt; mod_test:do(1).</p><p>2 </p></blockquote><p>我们看到并没有完成热更因为使用了非完全调用。<br>所以第一个问题的答案是一直不更新。</p><p>之后修改cal(X) -&gt; X + 3. 重新编译执行,</p><blockquote><p>14&gt; mod_test:do(1).</p><p>** exception error: bad argument<br>    in function  mod_test:do/1 (mod_test.erl, line 16)</p></blockquote><p>发现foo进程不存在， 所以第二个问题，内存中有三个版本时，系统 会杀死正在执行旧版本的进程。 </p><p>我们还可以将loop() 函数改成为完全限定试一下。<br>发现会在完全限定函数调用的时候改变成新的版本</p><p> 但是即便会用新的版本， 在热更新的时候也只能更新逻辑，而不是内存中的数据结构，因为我们影响的只是代码区    </p><h2 id="一些相关函数"><a href="#一些相关函数" class="headerlink" title="一些相关函数"></a>一些相关函数</h2><blockquote><p>code:purge(Module)         %% 删除旧版本的文件<br>code:load_file(Module)     %% 载入module 模块到内存<br>code:soft_purge(Module)  %% 相似于purge函数，但是只有在没有任何进程运行那块代码的时候</p></blockquote><hr><p><em>best wishes</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;加载&quot;&gt;&lt;a href=&quot;#加载&quot; class=&quot;headerlink&quot; title=&quot;加载&quot;&gt;&lt;/a&gt;加载&lt;/h2&gt;&lt;p&gt;调用一个 未加载的文件或者显示的code:load_file/1 函数调用的时候都会 触发erlang代码服务器动态加载代码&lt;/p&gt;
&lt;h2 id=&quot;热更新&quot;&gt;&lt;a href=&quot;#热更新&quot; class=&quot;headerlink&quot; title=&quot;热更新&quot;&gt;&lt;/a&gt;热更新&lt;/h2&gt;&lt;p&gt;当内存中的程序需要更新的时候， erlang VM 会维持两个版本， 一个是老版本 old , 一个是新版本 new.  热更新时，驻留在旧代码中的执行会继续执行旧的代码而其他情况下执行新的代码。&lt;br&gt;
    
    </summary>
    
    
      <category term="erlang" scheme="https://hongweikkx.github.io/tags/erlang/"/>
    
  </entry>
  
</feed>
