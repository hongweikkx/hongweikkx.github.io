<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kkx&#39;s blogs</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hongweikkx.github.io/"/>
  <updated>2018-07-17T16:22:08.859Z</updated>
  <id>https://hongweikkx.github.io/</id>
  
  <author>
    <name>kkx</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>读取.csv文件为.erl文件</title>
    <link href="https://hongweikkx.github.io/2018/07/14/%E8%AF%BB%E5%8F%96-csv%E6%96%87%E4%BB%B6%E4%B8%BA-erl%E6%96%87%E4%BB%B6/"/>
    <id>https://hongweikkx.github.io/2018/07/14/读取-csv文件为-erl文件/</id>
    <published>2018-07-14T14:25:25.000Z</published>
    <updated>2018-07-17T16:22:08.859Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-功能描述"><a href="#1-功能描述" class="headerlink" title="1. 功能描述"></a>1. 功能描述</h4><p>erlang游戏服务器经常会用到的一个功能模块就是将策划配置的.csv文件改写成 .erl 文件。所以我把这个功能单独写成了一个服务。<br><a id="more"></a></p><h4 id="2-服务git地址为"><a href="#2-服务git地址为" class="headerlink" title="2. 服务git地址为"></a>2. 服务git地址为</h4><p> <a href="https://github.com/hongweikkx/csv2erl.git" target="_blank" rel="noopener">https://github.com/hongweikkx/csv2erl.git</a></p><h4 id="3-功能效果："><a href="#3-功能效果：" class="headerlink" title="3. 功能效果："></a>3. 功能效果：</h4><p>.csv 文件<br><code>cat hero.csv</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hero_id,hero_name</span><br><span class="line">英雄id,英雄名字</span><br><span class="line">int,string</span><br><span class="line">1001,貂蝉</span><br><span class="line">1002,甄姬</span><br></pre></td></tr></table></figure></p><p>=&gt; .erl 文件<br><code>cat hero.erl</code><br><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-module</span><span class="params">(hero)</span>.</span><br><span class="line"><span class="keyword">-export</span><span class="params">([get/<span class="number">1</span>, get_all/<span class="number">0</span>])</span>.</span><br><span class="line"><span class="keyword">-include</span><span class="params">(<span class="string">"table_to_data_record.hrl"</span>)</span>.</span><br><span class="line"><span class="function"><span class="title">get</span><span class="params">(<span class="number">1001</span>)</span> -&gt;</span></span><br><span class="line">#data_hero&#123;</span><br><span class="line">hero_id = <span class="number">1001</span>,</span><br><span class="line">hero_name = [<span class="number">232</span>,<span class="number">178</span>,<span class="number">130</span>,<span class="number">232</span>,<span class="number">157</span>,<span class="number">137</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="title">get</span><span class="params">(<span class="number">1002</span>)</span> -&gt;</span></span><br><span class="line">#data_hero&#123;</span><br><span class="line">hero_id = <span class="number">1002</span>,</span><br><span class="line">hero_name = [<span class="number">231</span>,<span class="number">148</span>,<span class="number">132</span>,<span class="number">229</span>,<span class="number">167</span>,<span class="number">172</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="title">get</span><span class="params">(_)</span> -&gt;</span> not_find.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">get_all</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    [<span class="number">1001</span>,<span class="number">1002</span>].</span><br></pre></td></tr></table></figure></p><hr><p><em>best wishes</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-功能描述&quot;&gt;&lt;a href=&quot;#1-功能描述&quot; class=&quot;headerlink&quot; title=&quot;1. 功能描述&quot;&gt;&lt;/a&gt;1. 功能描述&lt;/h4&gt;&lt;p&gt;erlang游戏服务器经常会用到的一个功能模块就是将策划配置的.csv文件改写成 .erl 文件。所以我把这个功能单独写成了一个服务。&lt;br&gt;
    
    </summary>
    
    
      <category term="erlang" scheme="https://hongweikkx.github.io/tags/erlang/"/>
    
      <category term="csv" scheme="https://hongweikkx.github.io/tags/csv/"/>
    
  </entry>
  
  <entry>
    <title>erl&lt;=&gt;abstract_code</title>
    <link href="https://hongweikkx.github.io/2018/07/14/erl-abstract-code/"/>
    <id>https://hongweikkx.github.io/2018/07/14/erl-abstract-code/</id>
    <published>2018-07-14T14:19:51.000Z</published>
    <updated>2018-07-17T16:23:39.593Z</updated>
    
    <content type="html"><![CDATA[<h5 id="erl-gt-abstract-code"><a href="#erl-gt-abstract-code" class="headerlink" title="erl =&gt; abstract_code"></a>erl =&gt; abstract_code</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">erlc +debug_info test.erl</span><br><span class="line">&#123;ok, &#123;_, [&#123;abstract_code, &#123;_, Abs&#125;&#125;]&#125;&#125; = beam_lib:chunks(test, [abstract_code]).</span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="abstract-code-gt-erl"><a href="#abstract-code-gt-erl" class="headerlink" title="abstract_code =&gt; erl"></a>abstract_code =&gt; erl</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S = erl_prettypr:format(erl_syntax:form_list(Abs)).</span><br><span class="line">file:write_file(&quot;test_code&quot;, term_to_binary(S)).</span><br></pre></td></tr></table></figure><h5 id="ep"><a href="#ep" class="headerlink" title="ep:"></a>ep:</h5><h5 id="erl-gt-abstract-code-1"><a href="#erl-gt-abstract-code-1" class="headerlink" title="erl =&gt; abstract_code"></a>erl =&gt; abstract_code</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.erl</span><br><span class="line">-module(test).</span><br><span class="line">-export([start/0]).</span><br><span class="line">-ifdef(TEST).</span><br><span class="line">hello() -&gt;</span><br><span class="line">   io:format(&quot;########1~n&quot;).</span><br><span class="line">-else.</span><br><span class="line">hello() -&gt;</span><br><span class="line">   io:format(&quot;########2&quot;).</span><br><span class="line">-endif.</span><br><span class="line">start() -&gt;</span><br><span class="line">   hello().</span><br><span class="line">$</span><br><span class="line">$ erlc +debug_info test.erl</span><br><span class="line">$ erl</span><br><span class="line">1&gt; &#123;ok, &#123;_, [&#123;abstract_code, &#123;_, Abs&#125;&#125;]&#125;&#125;=beam_lib:chunks(test, [abstract_code                                 ]).</span><br><span class="line">&#123;ok,&#123;test,</span><br><span class="line">        [&#123;abstract_code,</span><br><span class="line">             &#123;raw_abstract_v1,</span><br><span class="line">                 [&#123;attribute,1,file,&#123;&quot;c:/Users/4399/Desktop/test.erl&quot;,1&#125;&#125;,</span><br><span class="line">                  &#123;attribute,1,module,test&#125;,</span><br><span class="line">                  &#123;attribute,2,export,[&#123;start,0&#125;]&#125;,</span><br><span class="line">                  &#123;function,7,hello,0,</span><br><span class="line">                      [&#123;clause,7,[],[],[&#123;call,8,&#123;remote,...&#125;,[...]&#125;]&#125;]&#125;,</span><br><span class="line">                  &#123;function,11,start,0,</span><br><span class="line">                      [&#123;clause,11,[],[],[&#123;call,12,&#123;...&#125;,...&#125;]&#125;]&#125;,</span><br><span class="line">                  &#123;eof,15&#125;]&#125;&#125;]&#125;&#125;</span><br></pre></td></tr></table></figure><h5 id="abstract-code-gt-erl-1"><a href="#abstract-code-gt-erl-1" class="headerlink" title="abstract_code =&gt; erl"></a>abstract_code =&gt; erl</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2&gt; S = erl_prettypr:format(erl_syntax:form_list(Abs)).</span><br><span class="line">&quot;-file(\&quot;c:/Users/4399/Desktop/test.erl\&quot;, 1).\n\n-module(test).\n\n-export([sta                                 rt/0]).\n\nhello() -&gt; io:format(\&quot;########2\&quot;).\n\nstart() -&gt; hello().\n\n&quot;</span><br><span class="line">3&gt; file:write_file(&quot;test_code&quot;, term_to_binary(S)).</span><br><span class="line">ok</span><br><span class="line">$ cat test_code</span><br><span class="line">僰▒-file(&quot;c:/Users/4399/Desktop/test.erl&quot;, 1).</span><br><span class="line"></span><br><span class="line">-module(test).</span><br><span class="line"></span><br><span class="line">-export([start/0]).</span><br><span class="line"></span><br><span class="line">hello() -&gt; io:format(&quot;########2&quot;).</span><br><span class="line"></span><br><span class="line">start() -&gt; hello().</span><br></pre></td></tr></table></figure><hr><p><em>best wishes</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;erl-gt-abstract-code&quot;&gt;&lt;a href=&quot;#erl-gt-abstract-code&quot; class=&quot;headerlink&quot; title=&quot;erl =&amp;gt; abstract_code&quot;&gt;&lt;/a&gt;erl =&amp;gt; abstract_code&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;erlc +debug_info test.erl&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;ok, &amp;#123;_, [&amp;#123;abstract_code, &amp;#123;_, Abs&amp;#125;&amp;#125;]&amp;#125;&amp;#125; = beam_lib:chunks(test, [abstract_code]).&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="erlang" scheme="https://hongweikkx.github.io/tags/erlang/"/>
    
  </entry>
  
  <entry>
    <title>erlang 热更新原理</title>
    <link href="https://hongweikkx.github.io/2018/07/13/erlang-%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://hongweikkx.github.io/2018/07/13/erlang-热更新原理/</id>
    <published>2018-07-13T15:10:12.000Z</published>
    <updated>2018-07-17T16:25:23.978Z</updated>
    
    <content type="html"><![CDATA[<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>调用一个 未加载的文件或者显示的code:load_file/1 函数调用的时候都会 触发erlang代码服务器动态加载代码</p><h2 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h2><p>当内存中的程序需要更新的时候， erlang VM 会维持两个版本， 一个是老版本 old , 一个是新版本 new.  热更新时，驻留在旧代码中的执行会继续执行旧的代码而其他情况下执行新的代码。<br><a id="more"></a><br>具体是：当函数调用为非限定调用的时候就使用旧代码， 而在使用M:F(A) 完全限定调用的时候， 就使用新的代码。<br>这个时候就会出现几个问题， </p><ol><li>如果一直调用local 代码是不是就一直不更新了？ </li><li>如果代码连续修改了两次，现在内存中就会有三个版本v(1) v(2) v(3)， 那么如果最初的版本v(1)还在执行会被怎么处理？</li></ol><p>用下面的代码来测试一下（代码来自elrang 编程指南）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-module(mod_test).</span><br><span class="line">-export([main/0, loop/0, cal/1, do/1]).</span><br><span class="line">main() -&gt;</span><br><span class="line">   register(foo, spawn(mod_test, loop,[])).</span><br><span class="line">  </span><br><span class="line">loop() -&gt;</span><br><span class="line">   receive</span><br><span class="line">      &#123;Sender, X&#125; -&gt;</span><br><span class="line">      Sender ! &#123;self(),cal(X)&#125;</span><br><span class="line">   end,</span><br><span class="line">   loop().</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">do(X) -&gt;</span><br><span class="line">    foo ! &#123;self(),X&#125;,</span><br><span class="line">    receive </span><br><span class="line">      &#123;_, Y&#125; -&gt;</span><br><span class="line">         Y</span><br><span class="line">    end.</span><br><span class="line">cal(X) -&gt;</span><br><span class="line">    X + 1.</span><br></pre></td></tr></table></figure><blockquote><p>1&gt; c(mod_test).</p><p>{ok,mod_test}</p><p>2&gt; mod_test:main().</p><p>true</p><p>3&gt; mod_test:do(1).</p><p>2</p></blockquote><p>之后修改cal(X) -&gt; X + 2.重新在原来的终端上编译</p><blockquote><p>4&gt; c(mod_test)</p><p>{ok,mod_test}</p><p>5&gt; mod_test:do(1).</p><p>2 </p></blockquote><p>我们看到并没有完成热更因为使用了非完全调用。<br>所以第一个问题的答案是一直不更新。</p><p>之后修改cal(X) -&gt; X + 3. 重新编译执行,</p><blockquote><p>14&gt; mod_test:do(1).</p><p>** exception error: bad argument<br>    in function  mod_test:do/1 (mod_test.erl, line 16)</p></blockquote><p>发现foo进程不存在， 所以第二个问题，内存中有三个版本时，系统 会杀死正在执行旧版本的进程。 </p><p>我们还可以将loop() 函数改成为完全限定试一下。<br>发现会在完全限定函数调用的时候改变成新的版本</p><p> 但是即便会用新的版本， 在热更新的时候也只能更新逻辑，而不是内存中的数据结构，因为我们影响的只是代码区    </p><h2 id="一些相关函数"><a href="#一些相关函数" class="headerlink" title="一些相关函数"></a>一些相关函数</h2><blockquote><p>code:purge(Module)         %% 删除旧版本的文件<br>code:load_file(Module)     %% 载入module 模块到内存<br>code:soft_purge(Module)  %% 相似于purge函数，但是只有在没有任何进程运行那块代码的时候</p></blockquote><hr><p><em>best wishes</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;加载&quot;&gt;&lt;a href=&quot;#加载&quot; class=&quot;headerlink&quot; title=&quot;加载&quot;&gt;&lt;/a&gt;加载&lt;/h2&gt;&lt;p&gt;调用一个 未加载的文件或者显示的code:load_file/1 函数调用的时候都会 触发erlang代码服务器动态加载代码&lt;/p&gt;
&lt;h2 id=&quot;热更新&quot;&gt;&lt;a href=&quot;#热更新&quot; class=&quot;headerlink&quot; title=&quot;热更新&quot;&gt;&lt;/a&gt;热更新&lt;/h2&gt;&lt;p&gt;当内存中的程序需要更新的时候， erlang VM 会维持两个版本， 一个是老版本 old , 一个是新版本 new.  热更新时，驻留在旧代码中的执行会继续执行旧的代码而其他情况下执行新的代码。&lt;br&gt;
    
    </summary>
    
    
      <category term="erlang" scheme="https://hongweikkx.github.io/tags/erlang/"/>
    
  </entry>
  
</feed>
